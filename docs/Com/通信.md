# 通信

通信 😀😀

## 送受信データの抽象化

マイコン間のデータ通信において、現在まで本ロボ研では送信するバイト列を直接操作して通信を行っていました。この方式はシンプルでわかりやすいのですが次のような問題があります。

- セグメンテーションフォルトが起きやすい。
- 送信側と受信側でデータを格納するインデックスをそろえないと正常に通信できない。
- 各バイトにどんなデータが入っているか送信側のプログラムを見ないとわからない。
- 浮動小数点の通信が困難。
- 1 バイト以上のデータ(int 型など)を送るにはバイト列に変換する処理をしなければならない。

これらの問題を解消するため、バイト列ではなくメッセージ(構造体)を使ってやり取りを行う方式に変更しました。メッセージを使用することで次のような利点があります。

- 構造体の各メンバには名前がついているため、どのようなデータが含まれるか明確。
- どのようなメッセージでやり取りするかさえ知れば通信できるので、プログラムの使いまわしがしやすい。
- 浮動小数点などの 1 バイトに収まらない型もメンバに定義するだけでやり取りできる。
- 誤り判定が容易

メッセージは直接やり取りできないので内部でバイト列にシリアライズして通信します。

具体的には次のようにメッセージを定義してやり取りします。(通信処理は省略)

```cpp
struct Vector2
{
    double x;
    double y;
    UDON_PARSABLE(x, y);  // 各メンバをパース可能にすることでシリアライズできるようになります。
};
```

```cpp
// 送信者
void loop()
{
    Vector2 vector { 100, 200 };

    // 構造体インスタンス -> バイト列
    const std::vector<uint8_t> packed = Udon::Pack(vector);

    // packedを送信...
}

// 受信者
void loop()
{
    // buffer(バイト列)に受信...
    const Udon::Optional<Vector2> unpacked = Udon::Unpack<Vector2>(buffer);

    if(unpacked)
    {
        // デシリアライズ成功
        Serial.print(unpacked->x);
        Serial.print(unpacked->y);
        Serial.println();
    }
    else
    {
        // デシリアライズ失敗(データの破損を検出)
        Serial.println("unpack failed");
    }
}
```
